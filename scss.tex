\begin{frame}{Stratégies de réécriture}
  \vspace{1cm}
  \begin{columns}[T]
    \begin{column}{0.5\textwidth}
      \begin{block}{}
        \begin{itemize}[<+->]
        \item \textit{Innermost}
        \item \textit{context-sensitive} (cs\textsc{trs})
        \item stratégie programmable
        \item \color{focusColorBis}{\textit{prefix-constrained} (\pctrs)}
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{overprint}
        \onslide<1>
        \begin{center}
          \begin{tikzpicture}
            
            \tikzstyle{focusedNode} = [shape = circle, thick, focusColor, fill=focusColor, draw];
            \tikzstyle{normalEdge} = [thick];
            
            \draw[thick, focusColorBis, fill=focusColorBis] (1,-3) -- ( 0,-5) -- (2,-5) -- cycle;
            
            \node (root) at (0,0) {};
            
            \node (a)    at (-2,-1) {};
            \node (b)    at ( 0,-1) {};
            \node (c)    at ( 2,-1) {};

            \node (aa)  at (-3,-2) {};
            \node (ab)  at (-2,-2) {};
            \node (ba)  at (-1,-2) {};
            \node (bb)  at (-0,-2) {};
            \node (bc)  at ( 1,-2) {};
            
            \node (bba)  at (-1,-3) {};
            \node[focusedNode] (bbb)  at ( 1,-3) {};

            \draw[normalEdge] (root) -- (a);
            \draw[normalEdge] (root) -- (b);
            \draw[normalEdge] (root) -- (c);

            \draw[normalEdge] (a) -- (aa);
            \draw[normalEdge] (a) -- (ab);
            \draw[normalEdge] (b) -- (ba);
            \draw[normalEdge] (b) -- (bb);
            \draw[normalEdge] (b) -- (bc);
            
            \draw[normalEdge] (bb) -- (bba);
            \draw[normalEdge] (bb) -- (bbb);
          \end{tikzpicture}
        \end{center}
        \onslide<2>
        \begin{center}
          \begin{tikzpicture}
            
            \tikzstyle{normalEdge} = [thick];
            \tikzstyle{focusedEdge} = [thick, focusColor];
            
            \node (f) at (0,0) {f};
            
            \node (fa)    at (-2,-1) {};
            \node (fb)    at ( 0,-1) {};
            \node (fc)    at ( 2,-1) {};

            \draw[focusedEdge] (f) -- (fa);
            \draw[normalEdge] (f) -- (fb);
            \draw[focusedEdge] (f) -- (fc);
          \end{tikzpicture}
          \begin{tikzpicture}
            
            \tikzstyle{normalEdge} = [thick];
            \tikzstyle{focusedEdge} = [thick, focusColor];

            \node (g) at (0,0) {g};
            
            \node (ga)    at (-2,-1) {};
            \node (gb)    at ( 0,-1) {};
            \node (gc)    at ( 2,-1) {};

            \draw[normalEdge] (g) -- (ga);
            \draw[focusedEdge] (g) -- (gb);
            \draw[focusedEdge] (g) -- (gc);
          \end{tikzpicture}
        \end{center}
        \onslide<3>
        \begin{center}
          \begin{itemize}
          \item Opérations élémentaires
          \item Opérations de contrôle de combinaison
          \item Opérations transversale
          \end{itemize}
        \end{center}
        \onslide<4>
        \begin{center}
          \begin{tikzpicture}

            \tikzstyle{focusedNode} = [shape = circle, thick, focusColor, fill=focusColor, draw];
            \tikzstyle{focusedEdge} = [thick, focusColorBis];
            \tikzstyle{normalEdge} = [thick];
            
            \node (root) at (0,0) {};
            
            \node (a)    at (-2,-1) {};
            \node (b)    at ( 0,-1) {};
            \node (c)    at ( 2,-1) {};

            \node (aa)  at (-3,-2) {};
            \node (ab)  at (-2,-2) {};
            \node (ba)  at (-1,-2) {};
            \node (bb)  at (-0,-2) {};
            \node (bc)  at ( 1,-2) {};
            
            \node (bba)  at (-1,-3) {};
            \node[focusedNode] (bbb)  at ( 1,-3) {};

            \draw[normalEdge] (root) -- (a);
            \draw[focusedEdge] (root) -- (b);
            \draw[normalEdge] (root) -- (c);

            \draw[normalEdge] (a) -- (aa);
            \draw[normalEdge] (a) -- (ab);
            \draw[normalEdge] (b) -- (ba);
            \draw[focusedEdge] (b) -- (bb);
            \draw[normalEdge] (b) -- (bc);
            
            \draw[normalEdge] (bb) -- (bba);
            \draw[focusedEdge] (bb) -- (bbb);
          \end{tikzpicture}
        \end{center}
      \end{overprint}
    \end{column}
  \end{columns}
  \vspace{-2cm}
  \begin{overprint}
    \onslide<2> JFP, 2004, J. Giesl et A. Middeldorp, {\footnotesize Transformation techniques for context-sensitive rewrite systems}\\
    \onslide<3> RTA, 2015, H. Cirstea, S. Lenglet et P.-E. Moreau, {\footnotesize A faithful encoding of programmable strategies into term rewriting systems}\\
    \onslide<4> SCSS, 2017, N. Andrianarivelo, V. Pelletier et P. Réty, {\footnotesize Transforming prefix-constrained or controlled rewrite systems}\\
  \end{overprint}
\end{frame}

\begin{frame}{\pctrs}
  \begin{itemize}
  \item $L : l \rightarrow r$
  \item $Dir(\Sigma) = \{\langle f, i \rangle \mid f \in \Sigma, 1 \leq i \leq arity(f)\}$
  \item $L$ automate de mots construit sur $Dir(\Sigma)$
  \end{itemize}
  \pause
  \begin{exampleblock}{Exemple}
    \begin{columns}
      \begin{column}{0.5\textwidth}
        \begin{itemize}
        \item $\Sigma = \{f^{\backslash 2}, g^{\backslash 2}, a^{\backslash 0}, b^{\backslash 0}\}$
        \item $R = \{L : a \rightarrow b\}$
        \item $L  = (\langle f,1 \rangle \cdot \langle g, 2 \rangle)^*$
        \item $t = f(g(a,a),a)$
        \end{itemize}
      \end{column}
      \begin{column}{0.5\textwidth}
        \begin{overprint}
          \onslide<2-3>
          \begin{tikzpicture}

            \tikzstyle{normalNode} = [black];
            \tikzstyle{focusNode} = [focusColor];
            \tikzstyle{focusNodeBis} = [focusColorBis];
            
            \tikzstyle{normalEdge} = [thick];
            \tikzstyle{focusEdge} = [thick, focusColorBis];

            \newcommand*\pathNodeStyle{normalNode};
            \newcommand*\targetNodeStyle{normalNode};

            \newcommand*\pathEdgeStyle{normalEdge};

            \only<3>{\renewcommand*\pathNodeStyle{focusNodeBis}}
            \only<3>{\renewcommand*\targetNodeStyle{focusNode}}

            \only<3>{\renewcommand*\pathEdgeStyle{focusEdge}}
            
            \node[\pathNodeStyle] (f) at (0,0) {$f$};
            \node[\pathNodeStyle] (g) at (-1,-1) {$g$};
            \node[normalNode] (a) at (-2,-2) {$a$};
            \node[\targetNodeStyle] (arw) at (0,-2) {$a$};
            \node[normalNode] (aa) at (1,-1) {$a$};

            \draw[\pathEdgeStyle] (f) -- (g);
            \draw[normalEdge] (f) -- (aa);
            \draw[normalEdge] (g) -- (a);
            \draw[\pathEdgeStyle] (g) -- (arw);
          \end{tikzpicture}
          \onslide<4->
          \begin{tikzpicture}

            \tikzstyle{normalNode} = [black];
            \tikzstyle{focusNode} = [focusColor];
            \tikzstyle{focusNodeBis} = [focusColorBis];
            
            \tikzstyle{normalEdge} = [thick];
            \tikzstyle{focusEdge} = [thick, focusColorBis];

            \newcommand*\pathNodeStyle{focusNodeBis}
            \newcommand*\targetNodeStyle{focusNode}

            \newcommand*\pathEdgeStyle{focusEdge}
            
            \node[\pathNodeStyle] (f) at (0,0) {$f$};
            \node[\pathNodeStyle] (g) at (-1,-1) {$g$};
            \node[normalNode] (a) at (-2,-2) {$a$};
            \node[\targetNodeStyle] (arw) at (0,-2) {$b$};
            \node[normalNode] (aa) at (1,-1) {$a$};

            \draw[\pathEdgeStyle] (f) -- (g);
            \draw[normalEdge] (f) -- (aa);
            \draw[normalEdge] (g) -- (a);
            \draw[\pathEdgeStyle] (g) -- (arw);
          \end{tikzpicture}
        \end{overprint}
      \end{column}
    \end{columns}
  \end{exampleblock}
\end{frame}

\begin{frame}{Transformation de \pctrs}
  \begin{overprint}
    \onslide<1>
    \begin{itemize}
    \item $R' = R'_1 \cup R'_2 \cup R'_3 \cup R'_4$
    \item $R'_1$ : Règles d'amorçage
    \item $R'_2$ : Règles de parcourt de l'automate
    \item $R'_3$ : Règles de réécriture du \pctrs
    \item $R'_4$ : Règles de remonté du jeton
    \end{itemize}
    \onslide<2>
    \begin{itemize}
    \item $R' = R'_1 \cup R'_2 \cup R'_3 \cup R'_4$
    \item $R'_1 = \{top(j(x)) \rightarrow top(q_I(x)) \mid q_I \in Q_I\}$
    \item $R'_2$ : Règles de parcourt de l'automate
    \item $R'_3$ : Règles de réécriture du \pctrs
    \item $R'_4$ : Règles de remonté du jeton
    \end{itemize}
    \onslide<3>
    \begin{itemize}
    \item $R' = R'_1 \cup R'_2 \cup R'_3 \cup R'_4$
    \item $R'_1 = \{top(j(x)) \rightarrow top(q_I(x)) \mid q_I \in Q_I\}$
    \item $R'_2 = \{q(f(x_1,\ldots,x_n))\rightarrow \delta(x_1,\ldots,q'(x_i),\ldots,x_n) \mid$\\
      ~~~~~~~~~~~$\delta=(q, \langle f,i \rangle, q') \in \Delta\}$
    \item $R'_3$ : Règles de réécriture du \pctrs
    \item $R'_4$ : Règles de remonté du jeton
    \end{itemize}
    \onslide<4>
    \begin{itemize}
    \item $R' = R'_1 \cup R'_2 \cup R'_3 \cup R'_4$
    \item $R'_1 = \{top(j(x)) \rightarrow top(q_I(x)) \mid q_I \in Q_I\}$
    \item $R'_2 = \{q(f(x_1,\ldots,x_n))\rightarrow \delta(x_1,\ldots,q'(x_i),\ldots,x_n) \mid$\\
      ~~~~~~~~~~~$\delta=(q, \langle f,i \rangle, q') \in \Delta\}$
    \item $R'_3 = \{q_f(l_k) \rightarrow j(r_k) \mid q_f \in Q_f^k,\, (L_k : l_k \rightarrow r_k) \in R\}$
    \item $R'_4$ : Règles de remonté du jeton
    \end{itemize}
    \onslide<5->
    \begin{itemize}
    \item $R' = R'_1 \cup R'_2 \cup R'_3 \cup R'_4$
    \item $R'_1 = \{top(j(x)) \rightarrow top(q_I(x)) \mid q_I \in Q_I\}$
    \item $R'_2 = \{q(f(x_1,\ldots,x_n))\rightarrow \delta(x_1,\ldots,q'(x_i),\ldots,x_n) \mid$\\
      ~~~~~~~~~~~$\delta=(q, \langle f,i \rangle, q') \in \Delta\}$
    \item $R'_3 = \{q_f(l_k) \rightarrow j(r_k) \mid q_f \in Q_f^k,\, (L_k : l_k \rightarrow r_k) \in R\}$
    \item $R'_4 = \{\delta(x_1,\ldots,j(x_i),\ldots,x_n)\rightarrow j(f(x_1,\ldots,x_i,\ldots,x_n)) \mid$\\
      ~~~~~~~~~~~$\delta=(q, \langle f,i \rangle, q') \in \Delta\}$
    \end{itemize}
  \end{overprint}
  \onslide<6->
  \begin{alertblock}{Théorème : {\small[SCSS, 2017, N. Andrianarivelo, V. Pelletier et P. Réty]}}
    Soit $t \in T(\Sigma)$. On a $t \rightarrow^*_{R_{pc}} t'$ si et seulement si $top(j(t)) \rightarrow^*_{R'} top(j(t'))$.
  \end{alertblock}
  \onslide<7->
  \begin{alertblock}{Théorème : {\small[SCSS, 2017, N. Andrianarivelo, V. Pelletier et P. Réty]}}
    Le \pctrs $R$ est terminant sur $\Sigma$ si et seulement si $R'$ est terminant sur $\Sigma'$.
  \end{alertblock}
\end{frame}

\begin{frame}{Exemple}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{itemize}
      \item $\Sigma = \{f^{\backslash 2}, g^{\backslash 2}, a^{\backslash 0}, b^{\backslash 0}\}$
      \item $R=\{(\langle f,1 \rangle.\langle g,2 \rangle)^* : a\rightarrow b\}$
      \item $Dir(\Sigma)=\{\langle f,1 \rangle,\langle f,2 \rangle, \langle g,1 \rangle, \langle g,2 \rangle\}$
      \end{itemize}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]
        \node[state,initial,accepting] (q) {$q$}; 
        \node[state] (q2) [right=of q] {$q'$};
      
        \path[->] 
        (q)   edge  [bend left]  node        {$\delta1 = (q,\langle f,1 \rangle, q')$} (q2)
        (q2)  edge  [bend left]  node        {$\delta2 = (q',\langle g,2 \rangle, q)$} (q);
      \end{tikzpicture}
      \vspace{\baselineskip}
    \end{column}
  \end{columns}
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{itemize}
      \item $R'_1= \{top(j(x)) \rightarrow top(q(x))\}$,
      \item $R'_2= \{q(f(x,y))\rightarrow \delta_1(q'(x),y),$\\$q'(g(x,y))\rightarrow \delta_2(x,q(y))\}$,
      \item $R'_3= \{q(a) \rightarrow j(b)\}$,
      \item $R'_4=\{\delta_1(j(x),y)\rightarrow j(f(x,y)),$\\$\delta_2(x,j(y))\rightarrow j(g(x,y))\}$.
      \end{itemize}
    \end{column}
    \begin{column}{0.4\textwidth}
      \begin{overprint}
        \onslide<1>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$f$}
          child { node {$g$}
            child {node {$a$}}
            child {node {$a$}}}
          child {node {$a$}};
        \end{tikzpicture}
        \onslide<2>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$j$}
            child{ node{$f$}
              child { node {$g$}
                child {node {$a$}}
                child {node {$a$}}}
              child {node {$a$}}}};
        \end{tikzpicture}
        \onslide<3>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$q$}
            child{ node{$f$}
              child { node {$g$}
                child {node {$a$}}
                child {node {$a$}}}
              child {node {$a$}}}};
        \end{tikzpicture}
        \onslide<4>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$\delta_1$}
            child{ node{$q'$}
              child { node {$g$}
                child {node {$a$}}
                child {node {$a$}}}
              child {node {$a$}}}};
        \end{tikzpicture}
        \onslide<5>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$\delta_1$}
              child { node {$\delta_2$}
                child {node {$a$}}
                child {node {$q$}
                  child {node {$a$}}}}
              child {node {$a$}}};
        \end{tikzpicture}
        \onslide<6>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$\delta_1$}
              child { node {$\delta_2$}
                child {node {$a$}}
                child {node {$j$}
                  child {node {$b$}}}}
              child {node {$a$}}};
        \end{tikzpicture}
        \onslide<7>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$\delta_1$}
            child{ node{$j$}
              child { node {$g$}
                child {node {$a$}}
                child {node {$b$}}}
              child {node {$a$}}}};
        \end{tikzpicture}
        \onslide<8>
        \begin{tikzpicture}[level distance = 1cm]
          \node {$top$}
          child { node {$j$}
            child{ node{$f$}
              child { node {$g$}
                child {node {$a$}}
                child {node {$b$}}}
              child {node {$a$}}}};
        \end{tikzpicture}
      \end{overprint}
    \end{column}
  \end{columns}
\end{frame}